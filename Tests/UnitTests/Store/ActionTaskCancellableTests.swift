import Foundation
import Testing

@testable import ViewFeature

/// Unit tests for ActionTask.cancellable(id:cancelInFlight:) functionality
@MainActor
@Suite struct ActionTaskCancellableTests {
  // MARK: - Test Fixtures

  enum TestAction {
    case search(String)
    case download(String)
  }

  @Observable
  final class TestState {
    var searchResults: [String] = []
    var downloads: [String: Data] = [:]
    var isSearching = false
    var isDownloading = false

    init() {}
  }

  // MARK: - cancellable(id:cancelInFlight:) Tests

  @Test func cancellable_withCancelInFlightFalse_doesNotModifyId() {
    // GIVEN: A run task with auto-generated ID
    let sut: ActionTask<TestAction, TestState> = .run { _ in }
      .cancellable(id: "search", cancelInFlight: false)

    // THEN: Should have the specified ID and cancelInFlight = false
    switch sut.storeTask {
    case .run(let id, _, _, let cancelInFlight):
      #expect(id == "search")
      #expect(!cancelInFlight)
    default:
      Issue.record("Expected run task")
    }
  }

  @Test func cancellable_withCancelInFlightTrue_setsFlag() {
    // GIVEN: A run task
    let sut: ActionTask<TestAction, TestState> = .run { _ in }
      .cancellable(id: "search", cancelInFlight: true)

    // THEN: Should have cancelInFlight = true
    switch sut.storeTask {
    case .run(let id, _, _, let cancelInFlight):
      #expect(id == "search")
      #expect(cancelInFlight)
    default:
      Issue.record("Expected run task")
    }
  }

  @Test func cancellable_overridesAutoGeneratedId() {
    // GIVEN: A run task with auto-generated ID, then override with cancellable
    let sut: ActionTask<TestAction, TestState> = .run { _ in }
      .cancellable(id: "new-id", cancelInFlight: false)

    // THEN: Should use the new ID from cancellable
    switch sut.storeTask {
    case .run(let id, _, _, _):
      #expect(id == "new-id")
    default:
      Issue.record("Expected run task")
    }
  }

  @Test func cancellable_withNoneTask_hasNoEffect() {
    // GIVEN: A none task
    let sut: ActionTask<TestAction, TestState> = .none
      .cancellable(id: "test", cancelInFlight: true)

    // THEN: Should remain none task
    switch sut.storeTask {
    case .none:
      #expect(Bool(true))
    default:
      Issue.record("Expected none task")
    }
  }

  @Test func cancellable_withCancelTask_hasNoEffect() {
    // GIVEN: A cancel task
    let sut: ActionTask<TestAction, TestState> = .cancel(id: "test")
      .cancellable(id: "new-id", cancelInFlight: true)

    // THEN: Should remain cancel task with original ID
    switch sut.storeTask {
    case .cancel(let id):
      #expect(id == "test")
    default:
      Issue.record("Expected cancel task")
    }
  }

  @Test func cancellable_canChainWithCatch() {
    // GIVEN: A run task with both cancellable and catch
    let sut: ActionTask<TestAction, TestState> = .run { _ in }
      .cancellable(id: "search", cancelInFlight: true)
      .catch { _, _ in }

    // THEN: Should have both ID, cancelInFlight, and error handler
    switch sut.storeTask {
    case .run(let id, _, let onError, let cancelInFlight):
      #expect(id == "search")
      #expect(cancelInFlight)
      #expect(onError != nil)
    default:
      Issue.record("Expected run task")
    }
  }

  @Test func cancellable_catchThenCancellable() {
    // GIVEN: A run task with catch then cancellable
    let sut: ActionTask<TestAction, TestState> = .run { _ in }
      .catch { _, _ in }
      .cancellable(id: "search", cancelInFlight: true)

    // THEN: Should preserve error handler and set cancellable
    switch sut.storeTask {
    case .run(let id, _, let onError, let cancelInFlight):
      #expect(id == "search")
      #expect(cancelInFlight)
      #expect(onError != nil)
    default:
      Issue.record("Expected run task")
    }
  }

  @Test func cancellable_withIntId() {
    // GIVEN: A run task with Int ID
    let sut: ActionTask<TestAction, TestState> = .run { _ in }
      .cancellable(id: 42, cancelInFlight: true)

    // THEN: Should convert Int to String
    switch sut.storeTask {
    case .run(let id, _, _, let cancelInFlight):
      #expect(id == "42")
      #expect(cancelInFlight)
    default:
      Issue.record("Expected run task")
    }
  }

  @Test func cancellable_withUUIDId() {
    // GIVEN: A run task with UUID ID
    let uuid = UUID()
    let sut: ActionTask<TestAction, TestState> = .run { _ in }
      .cancellable(id: uuid, cancelInFlight: true)

    // THEN: Should convert UUID to String
    switch sut.storeTask {
    case .run(let id, _, _, let cancelInFlight):
      #expect(id == uuid.uuidString)
      #expect(cancelInFlight)
    default:
      Issue.record("Expected run task")
    }
  }

  @Test func cancellable_withEnumId() {
    // GIVEN: A run task with enum ID
    enum TaskId: String, TaskIDConvertible {
      case search
      case download
    }

    let sut: ActionTask<TestAction, TestState> = .run { _ in }
      .cancellable(id: TaskId.search, cancelInFlight: true)

    // THEN: Should use enum raw value
    switch sut.storeTask {
    case .run(let id, _, _, let cancelInFlight):
      #expect(id == "search")
      #expect(cancelInFlight)
    default:
      Issue.record("Expected run task")
    }
  }

  @Test func cancellable_defaultCancelInFlightIsFalse() {
    // GIVEN: A run task with cancellable but no cancelInFlight parameter
    let sut: ActionTask<TestAction, TestState> = .run { _ in }
      .cancellable(id: "test")

    // THEN: cancelInFlight should default to false
    switch sut.storeTask {
    case .run(_, _, _, let cancelInFlight):
      #expect(!cancelInFlight)
    default:
      Issue.record("Expected run task")
    }
  }

  @Test func cancellable_multipleCallsLastOneWins() {
    // GIVEN: A run task with multiple cancellable calls
    let sut: ActionTask<TestAction, TestState> = .run { _ in }
      .cancellable(id: "first", cancelInFlight: false)
      .cancellable(id: "second", cancelInFlight: true)

    // THEN: Last call should override
    switch sut.storeTask {
    case .run(let id, _, _, let cancelInFlight):
      #expect(id == "second")
      #expect(cancelInFlight)
    default:
      Issue.record("Expected run task")
    }
  }
}
